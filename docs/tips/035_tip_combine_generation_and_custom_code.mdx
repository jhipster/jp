---
<<<<<<< HEAD:tips/035_tip_combine_generation_and_custom_code.md
layout: default
title: 生成コードとカスタム・コードの結合
sitemap:
priority: 0.1
lastmod: 2021-09-09T21:22:00-00:00
=======
title: Combining generation and custom code
slug: /tips/035_tip_combine_generation_and_custom_code.html
last_update:
  date: 2021-09-09T21:22:00-00:00
>>>>>>> upstream/main:docs/tips/035_tip_combine_generation_and_custom_code.mdx
---

__このTipは[@tcharl](https://github.com/tcharl)によって提出されました__

<<<<<<< HEAD:tips/035_tip_combine_generation_and_custom_code.md
# 生成コードとカスタム・コードの結合


_目標:_ Jhipsterは、その強力なドメイン固有言語のおかげで、モデルエンティティの管理に非常に適しています。
しかし、カスタムコードとジェネレーティブな世界の両方で最高のものを得ることは、常に困難な作業です。
ここでは、それを実現するために採用できるさまざまなパターンを紹介します。

## パターン1 - 初回のみ生成
=======
_Goal:_ Jhipster is very good for managing your model entities, thanks to its powerful Domain Specific language.
But getting the best both custom code and generative world is  always a hard task.
Here are the different pattern you can adopt in order to make it real. 


## Pattern 1 - Generate once
>>>>>>> upstream/main:docs/tips/035_tip_combine_generation_and_custom_code.mdx

このアプローチは最も単純であり、ほとんどのユース・ケースで使用されます。
これは、エンティティを一度モデリングし、最初のモデルを生成し、この最初のショットの後に必要なものをオーバーライドすることで構成されます。
ある日再同期したい場合は、いつでも別のブランチで再生成でき、IDEで両方のコードを比較できます。
しかし、その後のプロセスは常に苦痛であり、大規模なアップグレードには何日もかかる可能性があります。

### 長所

<<<<<<< HEAD:tips/035_tip_combine_generation_and_custom_code.md
 - 好きなようにできます。
=======
- Do what you want
>>>>>>> upstream/main:docs/tips/035_tip_combine_generation_and_custom_code.mdx

### 短所
 
<<<<<<< HEAD:tips/035_tip_combine_generation_and_custom_code.md
 - JHipsterの新機能の恩恵を受けられないことになります。
=======
- You'll tend do not benefit from JHipster new features

>>>>>>> upstream/main:docs/tips/035_tip_combine_generation_and_custom_code.mdx

## パターン2 - 生成コードとカスタムコードの分割

これは、生成されたクラスを変更するのを避け、カスタム・コードを専用のものとして立てるようにします。
ここでは、--with-generated-flagのjhipster cliオプションを使用して、生成されたクラスとカスタムクラスを簡単に区別できます。
最後に、生成されたホームページではなくカスタムホームページにルーティングするために、フロントエンド部分のメインルーターを変更するだけです。

ルータファイルが世代ごとに上書きされるのを避けるために、プロジェクトのルートに`.yo-resolve`ファイルを作成して、yeomanに期待される動作を伝えることができます。

<<<<<<< HEAD:tips/035_tip_combine_generation_and_custom_code.md
例：
=======
Example:

>>>>>>> upstream/main:docs/tips/035_tip_combine_generation_and_custom_code.mdx
```
src/main/resources/swagger/api.yml skip
src/main/webapp/app/modules/home/home.tsx skip
```

### 長所

- 生成とカスタムコードを簡単に組み合わせることができます。

### 短所

- デッドコードが存在します。
- モデルとは異なる名前やパッケージを持つカスタムクラスが存在することになります（DDDのベストプラクティスと考えることができますが、それでも）。

<<<<<<< HEAD:tips/035_tip_combine_generation_and_custom_code.md
## パターン3 - サイド・バイ・サイド
=======

## Pattern 3 - Side by side
>>>>>>> upstream/main:docs/tips/035_tip_combine_generation_and_custom_code.mdx

ここでの目標は、クラス拡張とBeanの優先順位を使用して、生成されたコードの代わりにカスタム・コードを注入することです。

`Customer`jhipsterエンティティの例を見てみましょう。

### リポジトリ

<<<<<<< HEAD:tips/035_tip_combine_generation_and_custom_code.md
リポジトリレベルでは、jhipsterが生成したリポジトリに`NoRepositoryBean`アノテーションを使用してアノテーションを付け、検出を無効にします。
次に、カスタムリポジトリクラスを作成します。
=======
At the repository level, you'll annotate jhipster generated repository using `NoRepositoryBean` annotation in order to disable discovery.
You can then create your custom repository class

>>>>>>> upstream/main:docs/tips/035_tip_combine_generation_and_custom_code.mdx
```
@Repository
@Primary
MemberRepositoryPrimary extends MemberRepository
```

### サービス

ここでは、ControllerにカスタムBeanを注入できるように、`serviceImpl`オプションを使用します。
次に、生成されたサービスを単純に拡張し、優先順位を得るためにBeanに`@Primary`というアノテーションを付けることができます。

### コントローラ

カスタム・エンドポイントには別のAPIプレフィックスを使用します（例えば`/api/v2`）。

### Angular

同じ拡張機能をフロントエンド側にも適用します。その後、`app.module.ts`ファイルでBeanの優先順位を設定します。
```
providers: [
// 別のエントリをキープする
{ provide: MemberDomainService, useExisting: MemberDomainServicePrimary },
]
```

### 長所

- 生成されたコードの動作をオーバーライドできます。
- カスタムコードの検索が容易です。
- カスタムコードに対してもJhipsterのベストレイアウトを維持できます。

### 短所

- ファイルの重複が発生します。
