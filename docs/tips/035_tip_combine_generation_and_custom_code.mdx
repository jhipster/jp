---
title: 生成コードとカスタム・コードの結合
slug: /tips/035_tip_combine_generation_and_custom_code.html
last_update:
  date: 2021-09-09T21:22:00-00:00
---

__このTipは[@tcharl](https://github.com/tcharl)によって提出されました__

# 生成コードとカスタム・コードの結合


_目標:_ Jhipsterは、その強力なドメイン固有言語のおかげで、モデルエンティティの管理に非常に適しています。
しかし、カスタムコードとジェネレーティブな世界の両方で最高のものを得ることは、常に困難な作業です。
ここでは、それを実現するために採用できるさまざまなパターンを紹介します。

## パターン1 - 初回のみ生成

このアプローチは最も単純であり、ほとんどのユース・ケースで使用されます。
これは、エンティティを一度モデリングし、最初のモデルを生成し、この最初のショットの後に必要なものをオーバーライドすることで構成されます。
ある日再同期したい場合は、いつでも別のブランチで再生成でき、IDEで両方のコードを比較できます。
しかし、その後のプロセスは常に苦痛であり、大規模なアップグレードには何日もかかる可能性があります。

### 長所

 - 好きなようにできます。

### 短所
 
 - JHipsterの新機能の恩恵を受けられないことになります。

## パターン2 - 生成コードとカスタムコードの分割

これは、生成されたクラスを変更するのを避け、カスタム・コードを専用のものとして立てるようにします。
ここでは、--with-generated-flagのjhipster cliオプションを使用して、生成されたクラスとカスタムクラスを簡単に区別できます。
最後に、生成されたホームページではなくカスタムホームページにルーティングするために、フロントエンド部分のメインルーターを変更するだけです。

ルータファイルが世代ごとに上書きされるのを避けるために、プロジェクトのルートに`.yo-resolve`ファイルを作成して、yeomanに期待される動作を伝えることができます。

例：
```
src/main/resources/swagger/api.yml skip
src/main/webapp/app/modules/home/home.tsx skip
```

### 長所

- 生成とカスタムコードを簡単に組み合わせることができます。

### 短所

- デッドコードが存在します。
- モデルとは異なる名前やパッケージを持つカスタムクラスが存在することになります（DDDのベストプラクティスと考えることができますが、それでも）。

## パターン3 - サイド・バイ・サイド

ここでの目標は、クラス拡張とBeanの優先順位を使用して、生成されたコードの代わりにカスタム・コードを注入することです。

`Customer`jhipsterエンティティの例を見てみましょう。

### リポジトリ

リポジトリレベルでは、jhipsterが生成したリポジトリに`NoRepositoryBean`アノテーションを使用してアノテーションを付け、検出を無効にします。
次に、カスタムリポジトリクラスを作成します。
```
@Repository
@Primary
MemberRepositoryPrimary extends MemberRepository
```

### サービス

ここでは、ControllerにカスタムBeanを注入できるように、`serviceImpl`オプションを使用します。
次に、生成されたサービスを単純に拡張し、優先順位を得るためにBeanに`@Primary`というアノテーションを付けることができます。

### コントローラ

カスタム・エンドポイントには別のAPIプレフィックスを使用します（例えば`/api/v2`）。

### Angular

同じ拡張機能をフロントエンド側にも適用します。その後、`app.module.ts`ファイルでBeanの優先順位を設定します。
```
providers: [
// 別のエントリをキープする
{ provide: MemberDomainService, useExisting: MemberDomainServicePrimary },
]
```

### 長所

- 生成されたコードの動作をオーバーライドできます。
- カスタムコードの検索が容易です。
- カスタムコードに対してもJhipsterのベストレイアウトを維持できます。

### 短所

<<<<<<< HEAD
- ファイルの重複が発生します。
=======
- File duplication

## Alternative Side-by-Side Approach

This approach aims to add functionality to an existing JHipster application with minimal changes to the generated code.

### Repository Tier

Create your repository interface with all custom methods in a separate custom package. This approach ensures that the generated repository code remains untouched, while your custom logic is organized and maintainable.

### Service Tier

There are three main approaches for adding custom code at this tier:

Aspect-Oriented Programming (AOP): 

AOP allows you to introduce cross-cutting concerns such as logging, security, or transaction management without altering the core business logic. This separation of concerns helps maintain cleaner and more modular code.

Event Listeners: 

If the new functionality is triggered by specific events in the application (e.g., after saving a Foo entity), you can use Spring's event listener mechanism. This keeps the core logic clean, though it may make the execution flow harder to trace.

Decorator Pattern: 

To add new methods or modify existing behavior in a controlled manner, the decorator pattern is highly recommended. This pattern involves wrapping the original class with a decorator that provides additional functionality. It is clean, testable, and requires minimal changes to the original client classes, ensuring better maintainability.

Step 1: Create or extend the existing Interface depending on how your service classes are generated
```
interface IFooService {
    void newFeature();
    //Existing method declarations
   ...
}
```
Step 2: Extension through Composition
```
@Service
@Qualifier("entended") 
public class ExtendedFooService implements FooService{
    private final FooService existingFooService;
    private final ExtendedFooRepository extendedFooRepository; // For new repository functionality
   ...
}
```
Step 3: Add the @Primary to the existing service class and mark the existing service class as an interface implementation in step 1.

Step 4: Change the attribute type of the original service client to the interface created in step 1.

You can omit step 1 and adjust related changes in the following steps for a simplified implementation of this approach if you are unlikely to have multiple implementations of a service method or don't expect frequent changes in a service method.  

### Web Tier

Create New Endpoint Controllers.
```
@RestController
@RequestMapping("/api/extended/foo")
public class ExtendedFooController {
    private final ExtendedFooService extendedFooService;
    
    public ExtendedFooController(ExtendedFooService extendedFooService) {
        this.extendedFooService = extendedFooService;
    }

    // New endpoints
    @GetMapping("/new-feature")
    public ResponseEntity<?> newFeature() {
        // Implementation
    }
}
```
>>>>>>> upstream/main
