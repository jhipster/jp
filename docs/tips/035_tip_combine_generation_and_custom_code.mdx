---
title: 生成コードとカスタムコードの結合
slug: /tips/035_tip_combine_generation_and_custom_code.html
last_update:
  date: 2021-09-09T21:22:00-00:00
---

__このTipは[@tcharl](https://github.com/tcharl)によって提出されました__

# 生成コードとカスタムコードの結合

_目標:_ JHipsterは、その強力なドメイン固有言語のおかげで、モデルエンティティの管理に非常に適しています。しかし、カスタムコードと生成コードの両方の利点を最大限に活かすことは、常に難しい作業です。ここでは、それを実現するために採用できる様々なパターンを紹介します。

## パターン1 - 初回のみ生成

このアプローチは最もシンプルで、多くのユースケースで使用できます。エンティティを一度モデリングし、最初のモデルを生成し、その後に必要な部分を上書きするというものです。再同期が必要な場合は、別のブランチで再生成し、IDEで両方のコードを比較できます。しかし、その後のプロセスは常に手間がかかり、大規模なアップグレードには数日かかる可能性があります。

### 長所

- 自由にカスタマイズできます。

### 短所

- JHipsterの新機能を利用できません。

## パターン2 - 生成コードとカスタムコードの分離

これは、生成されたクラスを変更せずに、カスタムコードを専用の場所に配置する方法です。`--with-generated-flag`オプションを使用して、生成されたクラスとカスタムクラスを簡単に区別できます。最後に、フロントエンド部分のメインルーターを変更して、生成されたホームページではなくカスタムホームページにルーティングします。

ルータファイルが生成によって上書きされるのを防ぐために、プロジェクトのルートに`.yo-resolve`ファイルを作成し、Yeomanに期待される動作を指定できます。

例：
```
src/main/resources/swagger/api.yml skip
src/main/webapp/app/modules/home/home.tsx skip
```

### 長所

- 生成コードとカスタムコードを簡単に組み合わせることができます。

### 短所

- デッドコードが存在します。
- モデルとは異なる名前やパッケージを持つカスタムクラスが存在することになります（DDDのベストプラクティスと考えることもできますが、それでも）。

## パターン3 - サイドバイサイド

ここでは、クラス拡張とBeanの優先順位を使用して、生成されたコードの代わりにカスタムコードを注入することを目指します。

`Customer` JHipsterエンティティの例を見てみましょう。

### リポジトリ

リポジトリレベルでは、JHipsterが生成したリポジトリに`@NoRepositoryBean`アノテーションを付けて検出を無効にします。次に、カスタムリポジトリクラスを作成します。
```
@Repository
@Primary
MemberRepositoryPrimary extends MemberRepository
```

### サービス

ここでは、`serviceImpl`オプションを使用して、コントローラーにカスタムBeanを注入できるようにします。次に、生成されたサービスを拡張し、Beanに`@Primary`アノテーションを付けて優先順位を得ます。

### コントローラー

カスタムエンドポイントは、別のAPIプレフィックス（例：`/api/v2`）を使用します。

### Angular

同じ拡張機能をフロントエンド側にも適用し、`app.module.ts`ファイルでBeanの優先順位を設定します。
```
providers: [
// 別のエントリをキープする
{ provide: MemberDomainService, useExisting: MemberDomainServicePrimary },
]
```

### 長所

- 生成されたコードの動作を上書きできます。
- カスタムコードの検索が容易です。
- カスタムコードに対してもJHipsterのベストプラクティスに従ったレイアウトを維持できます。

### 短所

- ファイルの重複が発生します。

## 代替的なサイドバイサイドアプローチ

このアプローチは、生成されたコードへの変更を最小限に抑えながら、既存のJHipsterアプリケーションに機能を追加することを目的としています。

### リポジトリ層

カスタムメソッドをすべて含むリポジトリインターフェースを、別のカスタムパッケージに作成します。このアプローチにより、生成されたリポジトリコードは変更されずに維持され、カスタムロジックは整理され、保守しやすくなります。

### サービス層

この層にカスタムコードを追加する方法は主に3つあります。

アスペクト指向プログラミング（AOP）：

AOPを使用すると、ロギング、セキュリティ、またはトランザクション管理などの横断的関心事を、コアビジネスロジックを変更せずに導入できます。この懸念事項の分離は、よりクリーンでモジュール化されたコードの維持に役立ちます。

イベントリスナー：

新しい機能がアプリケーション内の特定のイベント（例：Fooエンティティの保存後）によってトリガーされる場合は、Springのイベントリスナーメカニズムを使用できます。これにより、コアロジックはクリーンに保たれますが、実行フローの追跡が難しくなる可能性があります。

デコレータパターン：

制御された方法で新しいメソッドを追加したり、既存の動作を変更したりするには、デコレータパターンを強くお勧めします。このパターンは、追加の機能を提供するデコレータで元のクラスをラップすることを含みます。クリーンでテスト可能であり、元のクライアントクラスへの変更は最小限に抑えられ、保守性が向上します。

ステップ1：サービスクラスの生成方法に応じて、既存のインターフェースを作成するか拡張します。
```
interface IFooService {
    void newFeature();
    //既存のメソッド宣言
   ...
}
```
ステップ2：合成による拡張
```
@Service
@Qualifier("entended") 
public class ExtendedFooService implements FooService{
    private final FooService existingFooService;
    private final ExtendedFooRepository extendedFooRepository; // 新しいリポジトリ機能用
   ...
}
```
ステップ3：既存のサービスクラスに`@Primary`を追加し、ステップ1で既存のサービスクラスをインターフェースの実装としてマークします。

ステップ4：元のサービスクライアントの属性型を、ステップ1で作成したインターフェースに変更します。

サービスメソッドの複数の実装を持つ可能性が低い場合、またはサービスメソッドの頻繁な変更を期待しない場合は、ステップ1を省略し、次のステップで関連する変更を調整して、このアプローチの簡素化された実装を行うことができます。

### Web層

新しいエンドポイントコントローラーを作成します。
```
@RestController
@RequestMapping("/api/extended/foo")
public class ExtendedFooController {
    private final ExtendedFooService extendedFooService;

public ExtendedFooController(ExtendedFooService extendedFooService) {
        this.extendedFooService = extendedFooService;
    }

// 新しいエンドポイント
    @GetMapping("/new-feature")
    public ResponseEntity<?> newFeature() {
        // 実装
    }
}
```