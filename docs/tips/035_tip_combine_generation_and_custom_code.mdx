---
title: 生成コードとカスタムコードの結合
slug: /tips/035_tip_combine_generation_and_custom_code.html
last_update:
  date: 2021-09-09T21:22:00-00:00
---

__このTipは[@tcharl](https://github.com/tcharl)によって提出されました__

# 生成コードとカスタムコードの結合

目標：JHipsterは、その強力なドメイン固有言語のおかげで、モデルエンティティの管理に非常に適しています。しかし、カスタムコードとジェネレーティブな世界の両方で最高のものを得ることは、常に困難な作業です。ここでは、それを実現するために採用できるさまざまなパターンを紹介します。

## パターン1 - 初回のみ生成

このアプローチは最も単純であり、ほとんどのユースケースで使用されます。これは、エンティティを一度モデリングし、最初のモデルを生成し、この最初のショットの後に必要なものをオーバーライドすることで構成されます。ある日再同期したい場合は、いつでも別のブランチで再生成でき、IDEで両方のコードを比較できます。しかし、その後のプロセスは常に困難であり、大規模なアップグレードには何日もかかる可能性があります。

### 長所

- 好きなようにできます。

### 短所

- JHipsterの新機能の恩恵を受けられません。


## パターン2 - 生成コードとカスタムコードの分割

これは、生成されたクラスを変更するのを避け、カスタムコードを専用のものとして立てるようにします。ここでは、`--with-generated-flag`のJHipster CLIオプションを使用して、生成されたクラスとカスタムクラスを簡単に区別できます。最後に、生成されたホームページではなくカスタムホームページにルーティングするために、フロントエンド部分のメインルーターを変更するだけです。

ルータファイルが世代ごとに上書きされるのを避けるために、プロジェクトのルートに`.yo-resolve`ファイルを作成して、Yeomanに期待される動作を伝えることができます。

例：
```
src/main/resources/swagger/api.yml skip
src/main/webapp/app/modules/home/home.tsx skip
```

### 長所

- 生成とカスタムコードを簡単に組み合わせることができます。

### 短所

- デッドコードが存在します。
- モデルとは異なる名前やパッケージを持つカスタムクラスが存在することになります（DDDのベストプラクティスと考えることができますが、それでも）。


## パターン3 - サイドバイサイド

ここでの目標は、クラス拡張とBeanの優先順位を使用して、生成されたコードの代わりにカスタムコードを注入することです。

`Customer` JHipsterエンティティの例を見てみましょう。

### リポジトリ

リポジトリレベルでは、JHipsterが生成したリポジトリに`@NoRepositoryBean`アノテーションを使用してアノテーションを付け、検出を無効にします。次に、カスタムリポジトリクラスを作成します。
```
@Repository
@Primary
MemberRepositoryPrimary extends MemberRepository
```

### サービス

ここでは、ControllerにカスタムBeanを注入できるように、`serviceImpl`オプションを使用します。次に、生成されたサービスを単純に拡張し、優先順位を得るためにBeanに`@Primary`というアノテーションを付けることができます。

### コントローラ

カスタムエンドポイントには別のAPIプレフィックスを使用します（例えば`/api/v2`）。

### Angular

同じ拡張機能をフロントエンド側にも適用します。その後、`app.module.ts`ファイルでBeanの優先順位を設定します。
```
providers: [
// 別のエントリをキープする
{ provide: MemberDomainService, useExisting: MemberDomainServicePrimary },
]
```

### 長所

- 生成されたコードの動作をオーバーライドできます。
- カスタムコードの検索が容易です。
- カスタムコードに対してもJHipsterのベストレイアウトを維持できます。

### 短所

- ファイルの重複が発生します。

## 別のアプローチ：サイドバイサイド

このアプローチは、生成されたコードへの変更を最小限に抑え、既存のJHipsterアプリケーションに機能を追加することを目指しています。

### リポジトリ層

カスタムメソッドをすべて含むリポジトリインターフェースを、別のカスタムパッケージに作成します。このアプローチにより、生成されたリポジトリコードはそのまま維持され、カスタムロジックは整理され、保守しやすくなります。

### サービス層

この層にカスタムコードを追加するには、主に3つのアプローチがあります。

アスペクト指向プログラミング（AOP）：

AOPを使用すると、ロギング、セキュリティ、トランザクション管理などの横断的関心事を、コアビジネスロジックを変更せずに導入できます。この懸念事項の分離は、よりクリーンでモジュール化されたコードを維持するのに役立ちます。

イベントリスナー：

新しい機能がアプリケーション内の特定のイベント（例：Fooエンティティの保存後）によってトリガーされる場合、Springのイベントリスナーメカニズムを使用できます。これにより、コアロジックはクリーンに保たれますが、実行フローの追跡が難しくなる可能性があります。

デコレータパターン：

制御された方法で新しいメソッドを追加したり、既存の動作を変更したりするには、デコレータパターンを強くお勧めします。このパターンは、追加の機能を提供するデコレータで元のクラスをラップすることを含みます。クリーンでテスト可能であり、元のクライアントクラスへの変更が最小限に抑えられ、保守性が向上します。

ステップ1：サービスクラスの生成方法に応じて、既存のインターフェースを作成または拡張します。
```
interface IFooService {
    void newFeature();
    //既存のメソッド宣言
   ...
}
```
ステップ2：合成による拡張
```
@Service
@Qualifier("entended") 
public class ExtendedFooService implements FooService{
    private final FooService existingFooService;
    private final ExtendedFooRepository extendedFooRepository; // 新しいリポジトリ機能用
   ...
}
```
ステップ3：既存のサービスクラスに`@Primary`を追加し、ステップ1で既存のサービスクラスをインターフェースの実装としてマークします。

ステップ4：元のサービスクライアントの属性型を、ステップ1で作成したインターフェースに変更します。

サービスメソッドの複数の実装を持つ可能性が低い場合、またはサービスメソッドの頻繁な変更を期待しない場合は、ステップ1を省略し、後のステップで関連する変更を調整して、このアプローチの簡素化された実装を行うことができます。

### Web層

新しいエンドポイントコントローラーを作成します。
```
@RestController
@RequestMapping("/api/extended/foo")
public class ExtendedFooController {
    private final ExtendedFooService extendedFooService;

public ExtendedFooController(ExtendedFooService extendedFooService) {
        this.extendedFooService = extendedFooService;
    }

// 新しいエンドポイント
    @GetMapping("/new-feature")
    public ResponseEntity<?> newFeature() {
        // 実装
    }
}
```